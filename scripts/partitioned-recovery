#!/bin/bash

#set -x

# Runs a coordinator, 2 masters, and a 1 backup
# Client runs and reports its master down at the end of its run
# If everything works right the second master should recover the first

umask 0000

source ./scripts/common.bash

proto=fast+udp
#proto=tcp
#proto=infrc

host[0]=10.0.0.3
host[1]=10.0.0.4
host[2]=10.0.0.5
host[3]=10.0.0.6

C=$proto:host=${host[0]},port=12246
commonopts="-l 5 -C $C"

xstart() {
    xterm -e ssh -t -t $1 "umask 0000; export LD_LIBRARY_PATH=/usr/local/lib; $(pwd)/$OBJDIR/$2 $commonopts 2>&1 | tee /tmp/$3" &
    atexit "kill $!"
}

start() {
    ssh $1 "umask 0000; export LD_LIBRARY_PATH=/usr/local/lib; $(pwd)/$OBJDIR/$2 $commonopts > /tmp/$3 2>&1"  &
    atexit "kill $!"
}

startfg() {
    ssh $1 "umask 0000; export LD_LIBRARY_PATH=/usr/local/lib; $(pwd)/$OBJDIR/$2 $commonopts 2>&1 | tee /tmp/$3"
    atexit "kill $!"
}

suffix=.$$.rclog

# clean up any old logs
for h in ${host[@]}; do
    ssh $h 'rm /tmp/*rclog'
done

start ${host[0]} coordinator coordinator$suffix

sleep .5

start ${host[0]} "backup -m -L $proto:host=${host[0]},port=12243" backup1$suffix
start ${host[1]} "backup -m -L $proto:host=${host[1]},port=12244" backup2$suffix
start ${host[2]} "backup -m -L $proto:host=${host[2]},port=12241" backup3$suffix
start ${host[3]} "backup -m -L $proto:host=${host[3]},port=12240" backup4$suffix

sleep .5

start ${host[0]} "server -m 2048 -r 1 -L $proto:host=${host[0]},port=12242" master1$suffix
sleep .5
start ${host[1]} "server -m 2048 -r 1 -L $proto:host=${host[1]},port=12247" master2$suffix
sleep .5
start ${host[2]} "server -m 2048 -r 1 -L $proto:host=${host[2]},port=12248" master3$suffix

sleep .5

startfg ${host[0]} "client -d $*" client$suffix

#read

# sloppy version of cleaup in case ssh -t -t doesn't do the trick
for h in ${host[@]}; do
    atexit "ssh $h \"pkill backup; pkill server; pkill coordinator; pkill client\""
done

# aggregate logs
for h in ${host[@]}; do
    scp $h:/tmp/*$suffix /tmp > /dev/null
done

sort /tmp/*.rclog > /tmp/rclog

# Extract values and dump to stdout, useful when all processes are run in separate
# xterms, otherwise it's best to extract values directly from the leftover /tmp/rclog
awk '
/Performing/ { count=$6; size=$9; }
/read after recovery took/ { ticks=$9; }
/Bytes written/ { if ($7 != 0) { written=$7; } }
/Bytes logged/ { if ($8 != 0) { logged=$8; } }
END { print count " " size " " written " " logged " " ticks; }
' /tmp/rclog
