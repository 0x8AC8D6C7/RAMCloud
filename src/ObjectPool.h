/**
 * \file
 * This is a slightly modified version of boost::object_pool for RAMCloud's
 * purposes. Most importantly, it changes object_pool from calling pool's
 * ordered_malloc and ordered_free to using pool's malloc and free. This is
 * much more efficient, but does not provide any guarantees on the order in
 * which elements are freed.
 */

// Copyright (C) 2000, 2001 Stephen Cleary
//
// Distributed under the Boost Software License, Version 1.0:
//
// Boost Software License - Version 1.0 - August 17th, 2003
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
//
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.

// Prevents Weffc++ from complaining about this file
#pragma GCC system_header

#ifndef RAMCLOUD_OBJECTPOOL_H
#define RAMCLOUD_OBJECTPOOL_H

#include <boost/pool/poolfwd.hpp>
#include <boost/pool/pool.hpp>

namespace RAMCloud {

// T must have a non-throwing destructor
template <typename T,
          typename UserAllocator = boost::default_user_allocator_new_delete>
class ObjectPool: protected boost::pool<UserAllocator>
{
  public:
    typedef T element_type;
    typedef UserAllocator user_allocator;
    typedef typename boost::pool<UserAllocator>::size_type size_type;
    typedef typename boost::pool<UserAllocator>::difference_type
        difference_type;

  protected:
    boost::pool<UserAllocator> & store() { return *this; }
    const boost::pool<UserAllocator> & store() const { return *this; }

    // for the sake of code readability :)
    static void * & nextof(void * const ptr)
    { return *(static_cast<void **>(ptr)); }

  public:
    // This constructor parameter is an extension!
    explicit ObjectPool(const size_type next_size = 32)
    :boost::pool<UserAllocator>(sizeof(T), next_size) { }

    ~ObjectPool();

    // Returns 0 if out-of-memory
    element_type * malloc()
    { return static_cast<element_type *>(store().malloc()); }
    void free(element_type * const chunk)
    { store().free(chunk); }
    bool is_from(element_type * const chunk) const
    { return store().is_from(chunk); }

    template<typename... Args>
    element_type * construct(Args&&... args)
    {
      element_type * const ret = malloc();
      if (ret == 0)
        return ret;
      try {
          new(ret) element_type(static_cast<Args&&>(args)...);
      } catch (...) {
          free(ret);
          throw;
      }
      return ret;
    }

    void destroy(element_type * const chunk)
    {
      chunk->~T();
      free(chunk);
    }

    // These functions are extensions!
    size_type get_next_size() const { return store().get_next_size(); }
    void set_next_size(const size_type x) { store().set_next_size(x); }
};

template <typename T, typename UserAllocator>
ObjectPool<T, UserAllocator>::~ObjectPool()
{
  // handle trivial case
  if (!this->list.valid())
    return;

  boost::details::PODptr<size_type> iter = this->list;
  boost::details::PODptr<size_type> next = iter;

  // Start 'freed_iter' at beginning of free list
  void * freed_iter = this->first;

  const size_type partition_size = this->alloc_size();

  do
  {
    // increment next
    next = next.next();

    // delete all contained objects that aren't freed

    // Iterate 'i' through all chunks in the memory block
    for (char * i = iter.begin(); i != iter.end(); i += partition_size)
    {
      // If this chunk is free
      if (i == freed_iter)
      {
        // Increment freed_iter to point to next in free list
        freed_iter = nextof(freed_iter);

        // Continue searching chunks in the memory block
        continue;
      }

      // This chunk is not free (allocated), so call its destructor
      static_cast<T *>(static_cast<void *>(i))->~T();
      // and continue searching chunks in the memory block
    }

    // free storage
    UserAllocator::free(iter.begin());

    // increment iter
    iter = next;
  } while (iter.valid());

  // Make the block list empty so that the inherited destructor doesn't try to
  //  free it again.
  this->list.invalidate();
}

} // end RAMCloud

#endif  // RAMCLOUD_OBJECTPOOL_H
