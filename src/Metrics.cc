/* Copyright (c) 2011 Stanford University
 *
 * Permission to use, copy, modify, and distribute this software for
 * any purpose with or without fee is hereby granted, provided that
 * the above copyright notice and this permission notice appear in all
 * copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR(S) DISCLAIM ALL
 * WARRANTIES WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL
 * AUTHORS BE LIABLE FOR ANY SPECIAL, DIRECT, INDIRECT, OR
 * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
 * OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
 * NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

#include "Common.h"
#include "ShortMacros.h"
#include "Metrics.h"
#include "MetricList.pb.h"
#include "Segment.h"

namespace RAMCloud {

namespace {
    /// See #metrics.
    Metrics _metrics;
};

/**
 * Stores recovery metrics.
 * This is a pointer for future expansion. It always points to the same Metrics
 * object now.
 */
Metrics* metrics = &_metrics;

/**
 * This method is invoked when a service begins recovery.  It clears existing
 * metrics, unless some other service has already started recovery.
 */
void
Metrics::start()
{
    boost::unique_lock<boost::mutex> _(mutex);
    activeCount++;
    if (activeCount > 1)
        return;
    reset();

    // Set a few special values.
    clockFrequency = (uint64_t) Cycles::perSecond();
    pid = getpid();
    segmentSize = Segment::SEGMENT_SIZE;
}

/**
 * This method is called to indicate that a service has completed recovery.
 * Once all recovering services have called this method, metrics get dumped
 * to the log.
 */
void
Metrics::end()
{
    boost::unique_lock<boost::mutex> _(mutex);
    activeCount--;
    if (activeCount > 0)
        return;
    LOG(NOTICE, "Metrics:");
    for (int i = 0; i < numMetrics; i++) {
        MetricInfo info = metricInfo(i);
        LOG(NOTICE, "metrics->%s = %lu", info.name,
                static_cast<uint64_t>(*info.value));
    }
    LOG(NOTICE, "End of Metrics");
}

/**
 * Clear all of the counters stored in this object.
 */
void
Metrics::reset()
{
    for (int i = 0; i < numMetrics; i++) {
        MetricInfo info = metricInfo(i);
        *info.value = 0;
    }
}

/**
 * Generate a string that contains a serialized representation of all of the
 * performance counters.
 *
 * \param out
 *      The contents of this variable are replaced with a (binary) string
 *      formatted using Protocol Buffers and MetricList.proto.
 */
void
Metrics::serialize(std::string& out)
{
     ProtoBuf::MetricList list;
     for (int i = 0; i < numMetrics; i++) {
        MetricInfo info = metricInfo(i);
        ProtoBuf::MetricList_Entry* metric = list.add_metric();
        metric->set_name(info.name);
        metric->set_value(*info.value);
     }
     out.clear();
     list.SerializeToString(&out);
}

/**
 * Store metrics tracked on server side for Bench
 */
ServerStats serverStats;

}  // namespace RAMCloud

// This file is automatically generated from scripts/metrics.py; it defines
// the metricInfo method.
#include "Metrics.in.cc"
